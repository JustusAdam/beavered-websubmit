#lang forge

/* This file is auto-generated by dfpp version 0.0.0. */

abstract sig Label {}
abstract sig Object {
    labels: set Label
}
abstract sig Type extends Object {
    otype: set Type
}
one sig LectureQuestionSubmission extends Type {}
one sig LectureAnswer extends Type {}
abstract sig Src extends Object {}
abstract sig FnObj extends Object {}
abstract sig Fn extends Object {
    function: one FnObj
}
abstract sig Arg extends Src {}
abstract sig Call extends Src {}
abstract sig Ctrl extends Object {
    flow: set Src->Fn,
    sensitive: set Src,
    witness: set Src,
    types: set Src->Type
}

one sig arg2 extends Arg {}
one sig arg0 extends Arg {}
one sig call_get_answers extends Call {}

one sig delete_apikey extends FnObj {}
one sig delete_apikey_0 extends Fn {}
one sig delete_apikey_1 extends Fn {}
one sig send extends FnObj {}
one sig send_0 extends Fn {}
one sig send_1 extends Fn {}
one sig send_2 extends Fn {}
one sig send_3 extends Fn {}
one sig send_4 extends Fn {}
one sig insert extends FnObj {}
one sig insert_0 extends Fn {}
one sig insert_1 extends Fn {}
one sig insert_2 extends Fn {}
one sig replace extends FnObj {}
one sig replace_0 extends Fn {}
one sig replace_1 extends Fn {}
one sig replace_2 extends Fn {}
one sig delete_answer extends FnObj {}
one sig delete_answer_0 extends Fn {}
one sig delete_answer_1 extends Fn {}

one sig questions_submit_internal extends Ctrl {}
one sig forget_user extends Ctrl {}

one sig sensitivel extends Label {}
one sig stores extends Label {}
one sig deletes extends Label {}
one sig sends extends Label {}
one sig scopes extends Label {}

pred Flows {
    function = (
        (delete_apikey_0 + delete_apikey_1) -> delete_apikey +
        (send_0 + send_1 + send_2 + send_3 + send_4) -> send +
        (insert_0 + insert_1 + insert_2) -> insert +
        (replace_0 + replace_1 + replace_2) -> replace +
        (delete_answer_0 + delete_answer_1) -> delete_answer
    )
    questions_submit_internal.flow = (
        arg2->(replace_0 + replace_1 + send_0 + send_4 + replace_2) +
        arg0->(send_0 + replace_2 + replace_0 + send_1))
    questions_submit_internal.witness = arg0
    questions_submit_internal.sensitive = arg2
    questions_submit_internal.types = arg2->LectureQuestionSubmission
    
    forget_user.flow = (
        arg0->(delete_apikey_0 + delete_answer_0 + delete_answer_1) +
        call_get_answers->(delete_answer_0 + delete_answer_1))
    forget_user.witness = arg0
    forget_user.sensitive = call_get_answers
    forget_user.types = call_get_answers->LectureAnswer

    LectureQuestionSubmission.otype = LectureAnswer

    labels = (
        (delete_answer_0 + delete_apikey_0)->deletes +
        (replace_1 + replace_2)->stores +
        (LectureQuestionSubmission + arg2)->sensitivel +
        (send_3 + send_4)->sends +
        (send_2 + replace_2) -> scopes
    )
}

test expect {
    vacuity_Flows: {
        Flows
    } is sat
}

pred del_prop {
    some c: Ctrl |
    all t: Type | (some c0: Ctrl | some a: c0.sensitive | t in c0.types[a] and a->(replace_1 + replace_2) in c0.flow) 
        implies (some a: Src | some ot: Type | {
            ot = t or ot = t.otype
            a->ot in c.types 
            some a->(delete_answer_0 + delete_apikey_0) & c.flow
        })
}

pred flows_to[cs: Ctrl, o: Object, f : Fn] {
    some c: cs |
    some a : Src | {
        o = a or o in Type and a->o in c.types
        a -> f in c.flow
    }
}

fun labeled_objects[obs: Object, ls: Label] : set Object {
    labels.ls & obs
}


pred one_deleter {
    some c:Ctrl |
    all t: Type |
        sensitivel in t.labels and (some f: labeled_objects[Fn, stores] | flows_to[Ctrl, t, f])
        implies (some f: labeled_objects[Fn, deletes], ot: t.otype + t | flows_to[c, ot, f] )
}

test expect {
    vacuity_one_deleter_premise: {
        Flows
        some c:Ctrl |
        some t: Type |
            sensitivel in t.labels and (some f: labeled_objects[Fn, stores] | flows_to[Ctrl, t, f])
    } is sat
}

fun recipients[f: FnObj, ctrl: Ctrl] : set Src {
    ctrl.flow.(labeled_objects[arguments[f], scopes])
}

pred authorized[principal: Src, c: Ctrl] {
    some principal & c.witness
}

fun arguments[f : FnObj] : set Fn {
    function.f
}

pred outputs_to_authorized {
    all c: Ctrl, a : labeled_objects[Arg + Type, sensitivel], f : FnObj | 
        (some r : labeled_objects[arguments[f], sends] | flows_to[c, a, r]) 
        implies authorized[recipients[f, c], c]
}
pred stores_to_authorized {
    all c: Ctrl, a : labeled_objects[Arg + Type, sensitivel], f : FnObj | 
        (some r : labeled_objects[arguments[f], stores] | flows_to[c, a, r]) 
        implies authorized[recipients[f, c], c]
}

test expect {
    vacuity_outputs_to_authorized_premise: {
        Flows
        some c: Ctrl, a : labeled_objects[Arg + Type, sensitivel], f : FnObj | 
            (some r : labeled_objects[arguments[f], sends] | flows_to[c, a, r]) 
    } is sat

}
expect {
    only_send_sends: {
        Flows implies
        { f: FnObj |
            (some c: Ctrl, a : labeled_objects[Arg + Type, sensitivel] | 
            (some r : labeled_objects[arguments[f], sends] | flows_to[c, a, r]) )
            } = send
    } is theorem
    
}


test expect {
    only_arg2_of_t_lqs_leaks: {
        Flows implies
            {t: Type, c0: Ctrl, a: Arg  | a in c0.sensitive and t in c0.types[a] and a->(replace_1 + replace_2) in c0.flow } = LectureQuestionSubmission->questions_submit_internal->arg2
    } is theorem
}

pred delete_apikeyIsSafe[ctrl: one Ctrl]{
    all s: ctrl.sensitive & Arg |
        some (s->(delete_apikey_0)) & ctrl.flow
        implies ctrl.witness->(delete_apikey_0) in ctrl.flow
}
pred sendIsSafe[ctrl: one Ctrl]{
    all s: ctrl.sensitive & Arg |
        some (s->(send_3 + send_4)) & ctrl.flow
        implies ctrl.witness->(send_2) in ctrl.flow
}
pred insertIsSafe[ctrl: one Ctrl]{
    all s: ctrl.sensitive & Arg |
        some (s->(insert_2)) & ctrl.flow
        implies ctrl.witness->(insert_2) in ctrl.flow
}
pred replaceIsSafe[ctrl: one Ctrl]{
    all s: ctrl.sensitive & Arg |
        some (s->(replace_2)) & ctrl.flow
        implies ctrl.witness->(replace_2) in ctrl.flow
}
pred delete_answerIsSafe[ctrl: one Ctrl]{
    all s: ctrl.sensitive & Arg |
        some (s->(delete_answer_0)) & ctrl.flow
        implies ctrl.witness->(delete_answer_0) in ctrl.flow
}
test expect {
    data_is_deleted: {
        Flows implies one_deleter
    } is theorem
    stores_are_safe: {
        Flows implies stores_to_authorized
    } is theorem
    outputs_are_safe: {
        Flows implies outputs_to_authorized

    } is sat // we expect this property to be broken
}